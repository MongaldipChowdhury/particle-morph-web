<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Particle Morph</title>

<style>
body {
  margin: 0;
  background: black;
  overflow: hidden;
  font-family: Arial, sans-serif;
  color: white;
}
canvas {
  position: fixed;
  top: 0;
  left: 0;
}
.ui {
  position: fixed;
  top: 20px;
  left: 20px;
}
#status {
  margin-top: 10px;
  color: #00ff88;
  font-weight: bold;
}
</style>
</head>

<body>

<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>

<div class="ui">
  <h1>PARTICLE MORPH</h1>
  <p>4 Fingers = <b>DIP</b></p>
  <div id="status">Waiting...</div>
</div>

<!-- MediaPipe -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
// ================= CANVAS =================
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// ================= PARTICLE =================
class Particle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.tx = x;
    this.ty = y;
  }
  update() {
    this.x += (this.tx - this.x) * 0.08;
    this.y += (this.ty - this.y) * 0.08;
  }
  draw() {
    ctx.fillStyle = "#00ffff";
    ctx.beginPath();
    ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
    ctx.fill();
  }
}

let particles = [];

// ================= SHAPES =================
function heartShape(cx, cy) {
  const pts = [];
  for (let t = 0; t < Math.PI * 2; t += 0.05) {
    const x = 16 * Math.pow(Math.sin(t), 3);
    const y =
      13 * Math.cos(t) -
      5 * Math.cos(2 * t) -
      2 * Math.cos(3 * t) -
      Math.cos(4 * t);

    pts.push({
      x: cx + x * 10,
      y: cy - y * 10
    });
  }
  return pts;
}

function flowerShape(cx, cy) {
  const pts = [];
  for (let a = 0; a < Math.PI * 2; a += 0.08) {
    const r = 140 * Math.sin(5 * a);
    pts.push({
      x: cx + r * Math.cos(a),
      y: cy + r * Math.sin(a)
    });
  }
  return pts;
}

function textShape(text) {
  const off = document.createElement("canvas");
  off.width = 400;
  off.height = 200;
  const octx = off.getContext("2d");

  octx.fillStyle = "white";
  octx.font = "bold 120px Arial";
  octx.textAlign = "center";
  octx.fillText(text, 200, 140);

  const data = octx.getImageData(0, 0, 400, 200).data;
  const pts = [];

  for (let y = 0; y < 200; y += 4) {
    for (let x = 0; x < 400; x += 4) {
      if (data[(y * 400 + x) * 4 + 3] > 150) {
        pts.push({
          x: canvas.width / 2 - 200 + x,
          y: canvas.height / 2 - 100 + y
        });
      }
    }
  }
  return pts;
}

// ================= APPLY EFFECT =================
function morphTo(points) {
  particles = points.map(p => {
    const pt = new Particle(
      Math.random() * canvas.width,
      Math.random() * canvas.height
    );
    pt.tx = p.x;
    pt.ty = p.y;
    return pt;
  });
}

// ================= HAND =================
function countFingers(lm) {
  let c = 0;
  if (lm[4].x < lm[3].x) c++;
  if (lm[8].y < lm[6].y) c++;
  if (lm[12].y < lm[10].y) c++;
  if (lm[16].y < lm[14].y) c++;
  if (lm[20].y < lm[18].y) c++;
  return c;
}

const statusText = document.getElementById("status");
let lastGesture = -1;

// ================= MEDIAPIPE =================
const hands = new Hands({
  locateFile: f =>
    `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
});

hands.setOptions({
  maxNumHands: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7
});

hands.onResults(res => {
  if (res.multiHandLandmarks) {
    const count = countFingers(res.multiHandLandmarks[0]);

    if (count !== lastGesture) {
      lastGesture = count;

      const cx = canvas.width / 2;
      const cy = canvas.height / 2;

      if (count === 1) {
        statusText.innerText = "Heart";
        morphTo(heartShape(cx, cy));
      }
      else if (count === 3) {
        statusText.innerText = "Flower";
        morphTo(flowerShape(cx, cy));
      }
      else if (count === 4) {
        statusText.innerText = "DIP";
        morphTo(textShape("DIP"));
      }
      else if (count === 0) {
        statusText.innerText = "Collapse";
        particles = [];
      }
    }
  } else {
    statusText.innerText = "No Hand Detected";
  }
});

// ================= CAMERA =================
const camera = new Camera(document.getElementById("video"), {
  onFrame: async () => {
    await hands.send({ image: document.getElementById("video") });
  },
  width: 640,
  height: 480
});
camera.start();

// ================= LOOP =================
function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  particles.forEach(p => {
    p.update();
    p.draw();
  });
  requestAnimationFrame(animate);
}
animate();
</script>

</body>
</html>      statusText.innerText = "Collapse";
      particles.collapse();
      break;
    default:
      statusText.innerText = "Waiting...";
  }
}

const hands = new Hands({
  locateFile: f =>
    `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
});

hands.setOptions({
  maxNumHands: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7
});

hands.onResults(res => {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (res.multiHandLandmarks) {
    const fingerCount = countFingers(res.multiHandLandmarks[0]);
    applyEffect(fingerCount);
  } else {
    statusText.innerText = "No Hand Detected";
  }

  particles.draw(ctx);
});

const camera = new Camera(video, {
  onFrame: async () => {
    await hands.send({ image: video });
  },
  width: 640,
  height: 480
});
camera.start();
</script>

</body>
</html>
